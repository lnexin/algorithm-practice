package main

import (
	"fmt"
	"strconv"
)

func main() {
	fmt.Println(longestSubsequence("1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", 1))
}

// 2311. 小于等于 K 的最长二进制子序列
// 算术评级: 7

//给你一个二进制字符串 s 和一个正整数 k 。
//请你返回 s 的 最长 子序列的长度，且该子序列对应的 二进制 数字小于等于 k 。
//
//注意：
//子序列可以有 前导 0 。
//空字符串视为 0 。
//子序列 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。

func longestSubsequence(s string, k int) int {
	temp := ""
	allowGroup := true
	// 从右往左
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '0' {
			temp = "0" + temp
			continue
		}
		if !allowGroup {
			continue
		}
		if s[i] == '1' {
			// 如果是1的话就要看当前的这个二进制数是不是大于k
			// 二进制字符串转成10进制int
			newTemp := "1" + temp
			tempInt, err := strconv.ParseInt(newTemp, 2, 64)
			if err != nil {
				//return 0
			}
			if tempInt > int64(k) {
				allowGroup = false
			} else {
				temp = newTemp
			}
		}
	}
	return len(temp)
	// 统级0和1的个数
	//zeroCnt := 0
	//oneCnt := 0
	//for i := range s {
	//	if s[i] == '0' {
	//		zeroCnt++
	//	} else if s[i] == '1' {
	//		oneCnt++
	//
	//	}
	//}
	//
	//// k转换为二进制字符串
	//ks := strconv.FormatInt(int64(k), 2)
	//
	//// 计算最长子序列

}
